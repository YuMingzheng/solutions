---
title: 238. 除自身以外数组的乘积
date: 2025-01-09
tags:
  - 前缀数组
---

### 问题描述

[题目链接](https://leetcode.cn/problems/product-of-array-except-self/description/)

给定一个整数数组 `nums`，返回一个数组 `answer`，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 外所有元素的乘积。

注意：
1. 算法必须是 $O(n)$ 的。
2. 不能使用除法。

### 解题思路

#### 方法一

1. 首先扫描两遍，计算出前缀乘积数组和后缀乘积数组。
2. 然后遍历数组中的每个元素，$结果数组中的每个元素的值 = 当前位置的前缀乘积 \times 后缀乘积$。

注意：首元素和尾元素要进行特殊处理。

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        forward = [0] * len(nums)
        backward =[0] * len(nums)

        temp = 1
        for i in range(len(nums)):
            temp *= nums[i]
            forward[i] = temp
        temp = 1
        for j in range(len(nums)-1 , -1, -1):
            temp *= nums[j]
            backward[j] = temp
        ans = [0] * len(nums)
        for i in range(1, len(nums)-1):
            ans[i] = forward[i-1] * backward[i + 1]
        ans[0] = backward[1]
        ans[-1] = forward[-2]
        return ans
        
```


```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] forward  = new int[n];
        int[] backward = new int[n];
        for(int i = 0 ; i < n ; i ++){
            if(i == 0){
                forward[i] =  nums[i];
            }else{
                forward[i] = nums[i]* forward[i-1];
            }
        }
        for(int i = n-1 ; i >-1  ; i --){
            if(i == n-1){
                backward[i] = nums[i];
            }else{
                backward[i] = nums[i]*backward[i+1];
            }
        }

        int[] ans = new int[n];
        for(int i = 0 ; i < n ; i ++){
            if(i == 0){
                ans[i] = backward[i+1];
            }else if(i == n-1){
                ans[i] = forward[i-1];
            }else{
                ans[i] = forward[i-1]*backward[i+1];
            }
        }
        return ans;
    }
}
```





**算法复杂度分析：**

时间复杂度：$O(n)$

空间复杂度：$O(n)$
