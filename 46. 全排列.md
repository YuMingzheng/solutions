---
title: 46. 全排列
date: 2025-03-31
tags:
  - 回溯
---
### 问题描述

[题目链接](https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked)

nums不包含重复元素，求这个数组的全排列

### 解题思路

#### 方法一

- 使用result记录结果，使用used记录第i个位置的nums是否用过了，使用path记录当前的一次结果
- 回溯核心算法：
	- 如果深度`depth==nums.length`，将当前path加入到result中
	- 遍历每一个nums：
	- 如果used为false：
		- 当前path中加入nums[i]、used[i]=true
		- 递归dfs(nums , depth + 1)
		- 回溯：path移除最后一个（removeLast()）、当前位置设为false

```python
from copy import deepcopy
class Solution:
    def permute(self, nums):
        self.used = [False] * len(nums)
        self.path = []
        self.result = []
        self.dfs(nums, 0)
        return self.result

    def dfs(self, nums, depth):
        if depth == len(nums):
            self.result.append(deepcopy(self.path))
            
        for i in range(len(nums)):
            if not self.used[i]:
                self.path.append(nums[i])
                self.used[i] = True
                self.dfs(nums, depth + 1)
                self.path.pop()
                self.used[i] = False
```

```java
class Solution {
    
    List<Boolean> used = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    List<List<Integer>> result = new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        for(int i = 0 ;i < nums.length ; i++){
            used.add(false);
        }
        dfs(nums ,0);
        return result;
    }

    public void dfs(int[]  nums ,int depth){
        if(depth == nums.length){
            result.add(new ArrayList<>(path));
        }
        for(int i = 0 ; i < nums.length ; i ++){
            if(!used.get(i)){
                path.add(nums[i]);
                used.set(i , true);

                dfs(nums , depth + 1);

                path.removeLast();
                used.set(i , false);
            }
        }
        
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$
