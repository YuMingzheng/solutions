---
title: 213. 打家劫舍 II
date: 2025-04-01
tags:
  - 动态规划
---
### 问题描述

[题目链接](https://leetcode.cn/problems/house-robber-ii/description/)

在[[198. 打家劫舍]]的基础上，考虑房子成环

### 解题思路

#### 方法一


> 考虑两种情况，
>     从第1个到倒数第2个
>     从第2个到倒数第1个
> 然后取两种情况的最大值。

每一种情况下：
1. 确定dp数组（dp table）以及下标的含义
	1. `int[] dp`表示到第`i`家为止，最多能偷到的钱
2. 确定递推公式
	2. $dp[i] = max(dp[i-1] , dp[i-2] + nums[i])$
3. dp数组如何初始化
	1. `dp[0] = nums[0]`
	2. `dp[1] = max(dp[0],nums[1])`
4. 确定遍历顺序
	1. 从`i=2`开始遍历
5. 举例推导dp数组

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length <=2) return Arrays.stream(nums).max().getAsInt();
        return Math.max(
        rob_interval(nums , 0 , nums.length-1) , 
        rob_interval(nums , 1 , nums.length));
    }

    public int rob_interval(int[] nums , int left , int right){
        int[] dp = new int[nums.length];
        dp[left] = nums[left];
        dp[left + 1] = Math.max(nums[left] , nums[left + 1]);

        for (int i = left + 2; i < right; i++) {
            dp[i] = Math.max(dp[i -1] , dp[i -2] + nums[i]);
        }

        return dp[right-1];
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$
