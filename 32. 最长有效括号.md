---
title: 32. 最长有效括号
date: 2025-03-23
tags:
  - 栈
  - 动态规划
---
### 问题描述

[题目链接](https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

最长的有效括号的子串的长度

### 解题思路

#### 方法一

使用栈
1. 找到所有的有效括号匹配的index，存储下来idx
2. idx.sort()
3. 判断idx中连续的数字的最长长度

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stk = []
        idx = []
        # 1. 找到所有匹配括号的index
        for i , chr in enumerate(s):
            if chr == "(" or len(stk) == 0:
                stk.append((i,chr))
            elif len(stk) != 0:
                if stk[-1][1] == "(":
                    i_pop , _ = stk.pop()
                    idx.extend([i_pop , i])
		# 2 排序
        idx.sort()
        print(idx)
        
	    # 3 双指针找到连续数字的最长长度
        ptr_l = 0 
        res = 0
        for ptr_l in range(len(idx)-1):
            ptr_r = ptr_l
            while ptr_r<len(idx)-1 and idx[ptr_r] == idx[ptr_r+1] - 1:
                ptr_r += 1
            res = max(res, ptr_r-ptr_l + 1)
        return res
Solution().longestValidParentheses("()()(()")
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$

#### 方法二【动态规划】

使用`dp[i]`表示以`i`结尾的最长有效括号
1. 1. 当 `s[i]` 为 `(`,`dp[i]` 必然等于 `0`，因为不可能组成有效的括号；
2. 那么 `s[i]` 为 `)`
	1. 当 `s[i-1]` 为 `(`，那么 `dp[i] = dp[i-2] + 2`；
	2. 当 `s[i-1]` 为 `)` 并且 `s[i-dp[i-1] - 1]` 为 `(`，那么 `dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]`；

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        dp = [0] * len(s)
        res = 0
        for i , chr in enumerate(s):
            if i > 0 and s[i] == ')':
                if s[i - 1] == '(':
                    dp[i] = dp[i-2]+ 2
                elif s[i-1] == ')' and i - dp[i-1]-1 >= 0 and s[i - dp[i - 1] - 1] == "(":
                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]
                if dp[i] > res:
                    res = dp[i]
        return res
Solution().longestValidParentheses("()()(()")
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$


#### 方法三【更巧妙的用栈（不仅存入括号，也存入到目前位置的最优解）】

初始化栈时加入虚拟的下标-1,表示虚拟的右括号。在遍历字符串时，遇到左括号直接进栈，遇到右括号，如果栈顶是左括号，则可以匹配一个括号对，更新最大括号对长度，如果栈顶是右括号，或者虚拟的右括号-1，则将当前右括号入栈。


```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        # 加入虚拟的)
        n = len(s)
        res = 0
        for i in range(n):
            if s[i]=='(':
                stack.append(i)
            else:
                if stack[-1]==-1 or s[stack[-1]]==')':
                    # 如果栈顶是)
                    stack.append(i)
                else:
                    # 如果栈顶是(
                    stack.pop()
                    res = max(res,i-stack[-1])
        return res
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$