---
title: 34. 在排序数组中查找元素的第一个和最后一个位置
date: 2025-03-24
tags:
  - 二分法
---
### 问题描述

[题目链接](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)

排序数组中找到第一个和最后一个等于target的index

### 解题思路

#### 方法二

找==target-0.5==和==target+0.5==的下标
```python
def searchRange(self, nums: List[int], target: int) -> List[int]:
    def binarySearch(nums, low, high, target):
        if low > high:
            return low
        mid = (low + high) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            return binarySearch(nums, mid + 1, high, target)
        else:
            return binarySearch(nums, low, mid - 1, target)
    
    left, right = -1, -1
    
    left = binarySearch(nums, 0, len(nums) - 1, target - 0.5)
    
    right = binarySearch(nums, 0, len(nums) - 1, target + 0.5)
    if left >= len(nums) or nums[left] != target:
        return [-1, -1]
    else:
        return [left, right - 1]
```

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def binarySearch(nums, target):
            left , right = 0, len(nums) - 1
            while left <= right:
                mid = (left + right) // 2
                if nums[mid] == target:
                    return mid
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            return right + 1
        
        left, right = -1, -1
        
        left = binarySearch(nums, target - 0.5)
        right = binarySearch(nums,target + 0.5)
        
        if left >= len(nums) or nums[left] != target:
            return [-1, -1]
        else:
            return [left, right - 1]
```

#### 方法一

 两次二分，第一次找第一个等于target的位置，第二次找第一个大于target的位置

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        // 两次二分，第一次找第一个等于target的位置，第二次找第一个大于target的位置
        int left = 0;
        int right = nums.length - 1;
        int res_first = -1;
        int res_right = -1;

        // Step 1
        while(left <= right){
            int mid = (left + right) / 2;
            if(nums[mid] == target){
                res_first = mid;
                right = mid -1; // 关键
            }else if(nums[mid] > target){
                right = mid -1;
            }else{
                left = mid + 1;
            }
        }

        // Step 2
        left = 0;
        right = nums.length - 1;
        while(left <= right){
            int mid = (left + right) / 2;
            if(nums[mid] == target){
                res_right = mid;
                left = mid + 1; // 关键
            }else if (nums[mid] > target){
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }

        return new int[]{res_first , res_right};
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$

