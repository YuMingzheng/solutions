---
title: 76. 最小覆盖子串
date: 2025-01-11
tags:
  - 滑动窗口
---

### 问题描述

[题目链接](https://leetcode.cn/problems/minimum-window-substring/description/)

在字符串 `s` 里，找出包含字符串 `t` 中所有字符的最短子字符串。

不在乎字符出现的顺序，参杂别的字符也行。

### 解题思路

#### 方法一

使用双指针 `left` 和 `right` 来构建一个滑动窗口。首先，`right` 指针向右移动，尽可能扩展窗口，直到窗口满足条件。一旦满足条件，就停止扩展，因为目标是找到最小的子串，继续向右扩展只会使子串变大。尝试缩小窗口的左边界，将可以丢弃的字符移出窗口，直到遇到必须保留的字符。此时，记录窗口的长度，如果比之前记录的最小长度还要小，就更新记录。接下来，右移 `left` 指针，以新的左边界为起点，重复上述步骤，寻找下一个可能的最小子串。

```java
class Solution {
    public String minWindow(String s, String t) {
        int minLen = Integer.MAX_VALUE;
        int ansLeft = -1;
        int ansRight = -1;
        int left = 0;
        int right = 0;
        int sLen = s.length();
        int tLen = t.length();
        int[] need = new int[128];
        for (char c : t.toCharArray()) {
            need[c]++;
        }
        int needCount = tLen;
        while (right < sLen) {
            char rightChar = s.charAt(right);
            if (need[rightChar] > 0) {
                needCount--;
            }
            need[rightChar]--;
            if (needCount == 0) {
                char leftChar = s.charAt(left);
                while (need[leftChar] < 0) {
                    need[leftChar]++;
                    left++;
                    leftChar = s.charAt(left);
                }
                int currStrLen = right - left + 1;
                if (currStrLen < minLen) {
                    ansLeft = left;
                    ansRight = right;
                    minLen = currStrLen;
                }
                need[leftChar]++;
                left++;
                needCount++;
            }
            right++;
        }
        return ansLeft == -1 ? "" : s.substring(ansLeft, ansRight + 1);
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$

#### 方法二

1. 使用`from collections import Counter`，
2. 使用`cnt_s`记录窗口中各个字符出现的频数，
3. 依次拓展`ptr_r`指针，直到`cnt_s`能够cover掉`cnt_t`（表示真好覆盖）
	比较结果res，判断是否更新
4. 迭代`ptr_l += 1`
```python
from collections import Counter

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        cnt_s = Counter()
        cnt_t = Counter(t)
        ptr_l = 0
        ptr_r = 0
        
        res = len(s)+1
        res_l = -1
        res_r = len(s)
        while ptr_r < len(s):
            cnt_s[s[ptr_r]] += 1
            while cnt_s >= cnt_t: # 判断一个Counter是否cover另一个Counter
                if ptr_r - ptr_l < res:
                    res = ptr_r- ptr_l
                    res_l = ptr_l
                    res_r = ptr_r
                cnt_s[s[ptr_l]] -= 1
                ptr_l += 1
            ptr_r+=1
        return '' if res > len(s) else s[res_l : res_r + 1]

Solution().minWindow("ADOBECODEBANC" , "ABC")
```

