---
title: 300. 最长递增子序列
date: 2025-04-01
tags:
  - 动态规划
  - 子序列
---
### 问题描述

[题目链接](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)

数组`nums`中最长的递增子序列（可以不连续，但是要按照原来的先后顺序）的长度

### 解题思路

#### 方法一

1. 确定`dp`数组（dp table）以及下标的含义
	1. **`dp[i]`表示`i`之前包括`i`的以`nums[i]`结尾的最长递增子序列的长度**
2. 确定递推公式
	2. 位置`i`的最长升序子序列等于`j`从`0`到`i-1`各个位置的最长升序子序列 `+ 1` 的最大值。
	3. 所以：`if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);`
3. dp数组如何初始化
	1. `Arrays.fill(dp , 1);`
4. 确定遍历顺序
	1. 外层for从1开始遍历nums
		1. 内层for从j=0开始遍历到i
			1. 每次`nums[j]>nums[i]`，就判断要不要更新`dp[i]`
5. 举例推导dp数组

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        ans = 1
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
            ans = max(ans, dp[i])
        return ans
```


```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int res = 1;
        Arrays.fill(dp , 1);

        for(int i =  1 ; i < dp.length ; i ++){
            for(int j = 0 ; j < i ; j++){
                if(nums[i]>nums[j]){
                    dp[i] = Math.max(dp[i] , dp[j] + 1);
                }
            }
            res = Math.max(res, dp[i]);
        }

        return res;
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$
