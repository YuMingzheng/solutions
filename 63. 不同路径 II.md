---
title: 63. 不同路径 II
date: 2025-04-01
tags:
  - 动态规划
  - 多维动态规划
---
### 问题描述

[题目链接](https://leetcode.cn/problems/unique-paths-ii/description/)

在[[62. 不同路径]]的基础上，考虑某些网格点为障碍物的时候的不同路径数量。

### 解题思路

#### 方法一

就是将dp数组中，障碍物对应的值设置为0

1. 确定dp数组（dp table）以及下标的含义
	1. `int[][] dp = new int[m][n]`表示到每一个格子的不同路径有多少个
2. 确定递推公式
	1. 如果`障碍[i][j] == 0`，则continue跳过
	2. $dp[i][j] = dp[i-1][j] + dp[i][j-1]$
3. dp数组如何初始化
	1. 第一行和第一列均赋值为1，直到碰到障碍物，其余为0
4. 确定遍历顺序
	2. for i
		1. for j
5. 举例推导dp数组

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        dp = [[0]*len(grid[0])] * len(grid)

        dp[0][0] = grid[0][0]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == 0 and j == 0:
                    continue
                if i == 0:
                    dp[i][j] = dp[i][j-1] + grid[i][j]
                if j == 0:
                    dp[i][j] = dp[i-1][j] + grid[i][j]
                if i != 0 and j != 0:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        return dp[len(grid)-1][len(grid[0])-1]
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$
