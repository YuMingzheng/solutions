---
title: 63. 不同路径 II
date: 2025-04-01
tags:
  - 动态规划
  - 多维动态规划
---
### 问题描述

[题目链接](https://leetcode.cn/problems/unique-paths-ii/description/)

在[[62. 不同路径]]的基础上，考虑某些网格点为障碍物的时候的不同路径数量。

### 解题思路

#### 方法一

就是将dp数组中，障碍物对应的值设置为0

1. 确定dp数组（dp table）以及下标的含义
	1. `int[][] dp = new int[m][n]`表示到每一个格子的不同路径有多少个
2. 确定递推公式
	1. 如果`障碍[i][j] == 0`，则continue跳过
	2. $dp[i][j] = dp[i-1][j] + dp[i][j-1]$
3. dp数组如何初始化
	1. 第一行和第一列均赋值为1，直到碰到障碍物，其余为0
4. 确定遍历顺序
	2. for i
		1. for j
5. 举例推导dp数组

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] =  obstacleGrid[0][0] == 0 ?1:0;
        for(int i = 1 ; i < m ; i++){
            if(obstacleGrid[i][0] == 1) break;
            dp[i][0] = dp[i-1][0];
        }
        for(int j = 1 ; j < n ; j++){
            if(obstacleGrid[0][j] == 1) break;
            dp[0][j] = dp[0][j-1];
        }

        for(int i = 1 ; i < m ; i ++){
            for(int j = 1; j < n ; j++){
                if(obstacleGrid[i][j] == 1)continue;
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$
