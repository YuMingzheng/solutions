---
title: 23. 合并 K 个升序链表
date: 2025-03-30
tags:
  - 链表
---
### 问题描述

[题目链接](https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked)

合并k个按照升序排列的链表，返回合并后的头节点
### 解题思路

#### 方法一

将k个链表两两合并，递归

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return divide(lists , 0 , lists.length-1);
    }

	/*
	 划分区间
	*/
    public ListNode divide(ListNode[] lists , int left , int right){
        if(left > right){
            return null;
        }
        if(left == right){
            return lists[left];
        }
        int mid = (left + right) >> 1;
        ListNode l1 = divide(lists , left , mid );
        ListNode l2 = divide(lists , mid + 1 , right);
        return mergeTwo(l1 ,l2 );
    }

	/*
	两两合并
	*/
    public ListNode mergeTwo(ListNode node1 , ListNode node2){
        if(node1 == null){
            return node2;
        }
        if(node2 == null){
            return node1;
        }
        ListNode dummy = new ListNode();
        ListNode ptr = dummy;
        while(node1 != null && node2 != null){
            if(node1.val <= node2.val){
                ptr.next = node1;
                node1 = node1.next;
            }else{
                ptr.next = node2;
                node2 = node2.next;
            }
            ptr = ptr.next;
        }

        if(node1 == null){
            ptr.next = node2;
        }
        if(node2 == null){
            ptr.next = node1;
        }
        return dummy.next;
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$

#### 方法二

使用`PriorityQueue`

```java
class Solution {
   public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;
        PriorityQueue<ListNode> queue = new PriorityQueue<>((o1, o2) -> Integer.compare(o1.val , o2.val));
        ListNode dummy = new ListNode(0);
        ListNode p = dummy;
        for (ListNode node : lists) {
            if (node != null) queue.add(node);
        }
        while (!queue.isEmpty()) {
            p.next = queue.poll();
            p = p.next;
            if (p.next != null) queue.add(p.next);
        }
        return dummy.next;
    }
}
```