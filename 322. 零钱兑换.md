---
title: 322. 零钱兑换
date: 2025-04-01
tags:
  - 动态规划
  - 背包DP
---
### 问题描述

[题目链接](https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个不同面额的钱`coins`和一个总数`amount`，问凑成所需总数的最少硬币数量（每一种硬币数量无限）

### 解题思路

#### 方法一

1. 确定dp数组（dp table）以及下标的含义
	1. `int[] dp = new int[amount + 1]`表示凑成i所需要的最少硬币数量
2. 确定递推公式
	1. $dp[i]=min(dp[i] , dp[i-coin])$，$coin$表示当前所考虑的硬币面额
3. dp数组如何初始化
	1. `dp[0]`初始化为0
	2. 其余初始化为一个很大的数，可以用`amount + 1`
4. 确定遍历顺序
	1. 外层for循环遍历每一个总数
		1. 内层for循环遍历每一种面额
5. 举例推导dp数组

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for(int i = 0 ; i < dp.length ; i ++){
            for(int coin : coins){
                if(i - coin >= 0){
                    dp[i] = Math.min(dp[i] , dp[i - coin] + 1);
                }else{
                    break;
                }
            }
        }
        return  dp[dp.length -1] == amount + 1 ?-1 : dp[dp.length -1];
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$
