---
title: 62. 不同路径
date: 2025-04-01
tags:
  - 动态规划
  - 多维动态规划
---
### 问题描述

[题目链接](https://leetcode.cn/problems/unique-paths/description/?envType=study-plan-v2&envId=top-100-liked)

给一个$m\times n$的网格，问从左上角到右下角有多少条不同路径（每次只能往下或右移动一格）

### 解题思路

#### 方法一（dp）

1. 确定dp数组（dp table）以及下标的含义
	1. `int[][] dp = new int[m][n]`表示到每一个格子的不同路径有多少个
2. 确定递推公式
	1. $dp[i][j] = dp[i-1][j] + dp[i][j-1]$
3. dp数组如何初始化
	1. 第一行和第一列均赋值为1，其余为0
4. 确定遍历顺序
	1. for i
		1. for j
5. 举例推导dp数组

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0] * n] * m
        dp[0][0] = 1
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    continue
                if i == 0:
                    dp[i][j] = dp[i][j-1]
                if j == 0:
                    dp[i][j] = dp[i-1][j]
                if i != 0 and j != 0:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        
        return dp[m-1][n-1]
```



```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        dp[0][0] = 1;
        for(int i = 0 ; i < m ; i ++){
            for(int j = 0 ; j < n ; j ++){
                if(i == 0 && j == 0){
                    continue;
                }
                if(i == 0){
                    dp[i][j] = dp[i][j-1];
                }
                if(j == 0){
                    dp[i][j] = dp[i-1][j];
                }
                if(i != 0 && j != 0){
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$

#### 方法二（递归，会超时）

```java
class Solution {
    public int uniquePaths(int m, int n) {
        if(m == 1 || n == 1){
            return 1;
        }
        return uniquePaths(m , n-1) + uniquePaths(m-1 , n);
    }
}
```