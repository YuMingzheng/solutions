---
title: 39. 组合总和
date: 2025-03-31
tags:
  - 回溯
---
### 问题描述

[题目链接](https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&envId=top-100-liked)

给定数组`candidates`和目标`target`，从数组中找到和为target的==可重复选择==的子数组

**输入：**`candidates = [2,3,6,7], target = `7``
**输出：**`[[2,2,3],[7]]`

### 解题思路

#### 方法一

递归的时候更新当前累计值

- 回溯函数的参数：
	- 主函数传入参数`candidates`、`target`、当前累计加和`curr`、开始的下标（避免重复）`startIdx`
- 终止条件：
	- 如果`curr == target`，往结果中add当前path
	- 如果`curr > target`，return结束当前递归
- 单层遍历的逻辑：
	- 从`startIdx`出发
		- 每一次添加一位、递归（curr+当前值）、回溯

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(candidates , 0 , 0, target);
        return result;
    }

    public void backtracking(int[] candidates , int curr ,int startIdx , int target){
        if(curr == target){
            result.add(new ArrayList<>(path));
            return;
        }else if(curr > target){
            return;
        }
        for (int i = startIdx; i < candidates.length; i++) {
	        // 三步骤
	        // 1在path中记录当前值
            path.add(candidates[i]);
			// 2递归
            backtracking(candidates , curr + candidates[i] , i , target);
            // 3删除path的最后一个
            path.removeLast();
        }
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$
