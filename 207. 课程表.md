---
title: 207. 课程表
date: 2025-03-30
tags:
  - DFS
---
### 问题描述

[题目链接](https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-100-liked)

给一个先修课程对应关系，判断这个对应关系下能够修完所有课程
> `prerequisites`：其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程  `bi` 。

==其实就是判断网络图中是否有环，有环就不可行==

### 解题思路

#### 方法一

- 使用邻接表`adjacency`构建网络图；
- 使用DFS判断网络中有没有图；
- 使用`int[] flags`记录节点状态：
	- `0`：未被dfs访问
	- `-1`：被其他节点启动的dfs访问
	- `1`：被当前节点启动的dfs访问
- 对每个节点启动`dfs`判断当前节点启动的是否有环，存在环直接返回`false`
-  `dfs`流程：
	- 终止条件：
		- 当`flag[i]==-1`，说明当前节点被其他节点的`dfs`访问过了，不需要重新访问，直接返回`true`
		- 当`flag[i]==1`，说明碰到环了，返回`false`
	- 将当前节点`i`对应的`flags`设置为`1`
	- 递归访问当前节点`i`的所有邻接节点`j`，当发现环直接返回 `False`；
	- 当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点 `flag` 置为 `−1` 并返回` True`
- 若整个图`dfs`结束均没有发现环，返回true

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> adjacency = new ArrayList<>();
        for(int i = 0 ; i < numCourses ; i++){
            adjacency.add(new ArrayList<>());
        }
        int[] flags = new int[numCourses];
        for(int[] one : prerequisites){
            adjacency.get(one[1]).add(one[0]);
        }

        for(int i = 0 ; i < numCourses ; i++){
            if(!dfs(adjacency , flags , i)){
                return false;
            }
        }
        return true;
    }

    public boolean dfs(List<List<Integer>> adjacency , int[] flag , int i){
        if(flag[i] == 1) return false;
        if(flag[i] == -1) return true;
        flag[i] = 1;
        for(Integer j : adjacency.get(i)){
            if(!dfs(adjacency , flag , j)){
                return false;
            }
        }
        flag[i] = -1;
        return true;
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$
