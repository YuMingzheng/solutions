---
title: 148. 排序链表
date: 2025-03-27
tags:
  - 链表
---
### 问题描述

[题目链接](https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-100-liked)

排序链表

### 解题思路
#### 方法1
- 使用归并排序
- 涉及到：
	- 找到一个链表的中点
	- 合并两个有序链表
```python
class Solution:
    # 获取链表的中点
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            pre = slow
            slow = slow.next
            fast = fast.next.next
        pre.next = None

        return slow
    
    # 合并两个有序链表
    def mergeTwoSortedLists(self, list1, list2):
        cur = dummy = ListNode()
        while list1 and list2:
            if list1.val < list2.val:
                cur.next = list1
                list1 = list1.next
            else:
                cur.next = list2
                list2  = list2.next
            cur = cur.next
        
        cur.next = list1 if list1 else list2

        return dummy.next

    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None or head.next == None:
            return head
        
        head2 = self.middleNode(head)
        head = self.sortList(head)
        head2 = self.sortList(head2)

        return self.mergeTwoSortedLists(head, head2)
        
```


#### 方法?

使用`PriorityQueue`

```java
class Solution {
    public ListNode sortList(ListNode head) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((n1,n2)->Integer.compare(n1.val,n2.val));
        ListNode ptr = head;
        while(ptr != null){
            pq.offer(new ListNode(ptr.val));
            ptr = ptr.next;
        }
        ListNode dummy = new ListNode();
        ListNode ptrD = dummy;
        while(!pq.isEmpty()){
            ptrD.next = pq.poll();
            ptrD = ptrD.next;
        }

        return dummy.next;
    }
}
```

**算法复杂度分析：**

时间复杂度：$O(nlogn)$

空间复杂度：$O(n)$
