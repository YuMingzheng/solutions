---
title: 438. 找到字符串中所有字母异位词
date: 2025-01-05
tags:
  - 滑动窗口
---

### 问题描述

[题目链接](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

在字符串 `s` 中，找到所有字符出现次数与字符串 `p` 相同但排列顺序不同的子串，并返回这些子串的起始索引。

### 解题思路

#### 方法一

使用滑动窗口法，利用一个 `HashMap` 记录字符串 `p` 中每个字符的出现次数，另一个 `HashMap` 用于记录当前窗口中每个字符的出现次数。随着窗口向后移动，每次向窗口的后端加入一个新字符的同时，从窗口的前端移除一个字符，然后比较两个 `HashMap` 的内容。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new ArrayList<>();

        if(s.length() < p.length()){
            return ans;
        }

        HashMap<Character,Integer> pMap = new HashMap<>();
        int windowSize = p.length();
        for(int i = 0 ; i < windowSize; i++){
            char pc = p.charAt(i);
            pMap.put(pc , pMap.getOrDefault(pc,0) + 1);
        }

        HashMap<Character , Integer> windMap = new HashMap<>();
        for(int i = 0 ; i < windowSize ; i ++){
            char sc = s.charAt(i);
            windMap.put(sc , windMap.getOrDefault(sc , 0) + 1);
        }

        for (int i = 0 ; i <= s.length() - windowSize; i++){
            if(windMap.equals(pMap)){
                ans.add(i);
            }
            if(i == s.length() - windowSize){
                break;
            }

            char newChar = s.charAt(i + windowSize);
            windMap.put(newChar , windMap.getOrDefault(newChar,0)+ 1);

            char outChar = s.charAt(i);
            if(windMap.get(outChar) == 1){
                windMap.remove(outChar);
            }else{
                windMap.put(outChar,windMap.getOrDefault(outChar,0) -1);
            }
        }

        return ans;
    }
}
```

**算法复杂度分析：**

时间复杂度：$O(n)$

空间复杂度：$O(n)$
