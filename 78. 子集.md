---
title: 78. 子集
date: 2025-03-31
tags:
  - 回溯
---
### 问题描述

[题目链接](https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked)

`nums`元素不互相同，给出该数据所有可能的子集（tips：别忘了空集和全集）
### 解题思路

#### 方法一

其实就是找到树的每一个叶子节点

```java
class Solution {
    List<List<Integer>> result= new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> subsets(int[] nums) {
        backtracking(nums ,0);
        return result;
    }


    public void backtracking(int[] nums,int startIndex){
        result.add(new ArrayList<>(path));

        for (int i =startIndex;i<nums.length;i++){
            path.add(nums[i]);
            backtracking(nums,i+1);
            path.removeLast();
        }
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$

#### 方法二

，当然也可以借鉴[[77. 组合]]，遍历每一个k

```java
class Solution {
    List<List<Integer>> result= new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> subsets(int[] nums) {
        for(int i = 0 ; i < nums.length ; i ++){
            backtracking(nums , i , 0);
        }
        List<Integer> temp = new ArrayList<>();
        for(int num : nums){
            temp.add(num);
        }
        result.add(temp);
        return result;
    }


    public List<List<Integer>> combine(int[] nums, int k) {
        backtracking(nums,k,0);
        return result;
    }

    public void backtracking(int[] nums,int k,int startIndex){
        if (path.size() == k){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i =startIndex;i<nums.length;i++){
            path.add(nums[i]);
            backtracking(nums,k,i+1);
            path.removeLast();
        }
    }
}
```