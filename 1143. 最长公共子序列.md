---
title: 1143. 最长公共子序列
date: 2025-04-02
tags:
  - 动态规划
  - 多维动态规划
---
### 问题描述

[题目链接](https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)

两个字符串`text1`和`text2`的最长公共子序列（不一定连续，但是要保留先后顺序）的长度

### 解题思路

#### 方法一

1. 确定dp数组（dp table）以及下标的含义
	1. `dp[i][j]`，表示`text1[0:i]`和`text[0:j]`的最长公共子序列长度。
2. 确定递推公式
	$dp[i][j]=dp[i−1][j−1]+1,text1[i]=text2[j]​$
	$dp[i][j]=max(dp[i][j−1],dp[i−1][j]),text1[i]!=text2[j]​$
3. dp数组如何初始化
	1. 0
4. 确定遍历顺序
5. 举例推导dp数组

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m+1][n+1];

        for(int i = 1; i <= m ; i++){
            char c1 = text1.charAt(i-1);
            for(int j = 1; j <= n; j++){
                if(c1 == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j] , dp[i][j-1]);
                }
            }
        }

        return dp[m][n];
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$
