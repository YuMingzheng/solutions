---
title: 139. 单词拆分
date: 2025-04-01
tags:
  - 动态规划
  - 背包DP
---
### 问题描述

[题目链接](https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

### 解题思路

#### 方法一

该问题也是背包问题的一个变种：即字符串列表中每一个字符串是一个物品，目标字符串是背包，问物品能不能装满背包

1. 确定dp数组（dp table）以及下标的含义
	1. `boolean[] dp = new boolean[s.length()+1]`表示从0到i的s的字串能不能由给定的字典表示
2. 确定递推公式
	1. 对于`[0,j]`的字串对应的`dp[j]`，如果`dp[i]`为true、并且`[i,j]`这一段的字串在字典中，那么`dp[j]=true`
3. dp数组如何初始化
	1. `dp[0]=true`
4. 确定遍历顺序
	1. 外层for循环遍历从0到每一个下标对应的字串s.subString()
		1. 内层for循环遍历字典中每一个元素
5. 举例推导dp数组

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;

        for(int i = 1 ; i <= s.length(); i++){
            for(String word : wordDict){
                int len = word.length();
                if(i - len >= 0 && dp[i-len] == true && word.equals(s.substring(i-len , i))){
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[dp.length-1];
    }
}
```

**算法复杂度分析：**

时间复杂度：$O()$

空间复杂度：$O()$
